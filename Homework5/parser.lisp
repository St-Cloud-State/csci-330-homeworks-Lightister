(defvar *input* nil)  ; Input string
(defvar *pos* 0)      ; Current position in the input string
(defun peek ()
  (if (< *pos* (length *input*))
      (char *input* *pos*)
      nil))
(defun next-char ()
  (if (< *pos* (length *input*))
      (let ((c (char *input* *pos*)))
        (incf *pos*)
        c)
      nil))
(defun match (c)
  (let ((current (peek)))
    (if (and current (char= current c))
        (progn (next-char) t)
        nil)))
(defun parse-I ())
(defun parse-I-prime ())
(defun parse-E ())
(defun parse-E-prime ())
(defun parse-G ())
(defun parse-S ())
(defun parse-L ())
(defun parse-L-prime ())
(defun parse-I ()
  "Parse I → iES I'."
  (if (match #\i)
      (and (parse-E)
           (parse-S)
           (parse-I-prime))
      nil))
(defun parse-I-prime ()
  "Parse I' → eS | ε."
  (if (match #\e)
      (and (parse-S))
      t))  
(defun parse-E ()
  (and (parse-G)
       (parse-E-prime)))
(defun parse-E-prime ()
  (if (match #\o)
      (and (parse-G)
           (parse-E-prime))
      t))  ; Epsilon case
(defun parse-G ()
  (let ((current (peek)))
    (cond
      ((char= current #\x) (match #\x))
      ((char= current #\y) (match #\y))
      ((char= current #\z) (match #\z))
      ((char= current #\w) (match #\w))
      (t nil))))
(defun parse-S ()
  (let ((current (peek)))
    (cond
      ((char= current #\s) (match #\s))
      ((char= current #\d) (and (match #\d)
                               (parse-L)
                               (match #\b)))
      (t nil))))
(defun parse-L ()
  (if (match #\s)
      (parse-L-prime)
      nil))
(defun parse-L-prime ()
  (if (and (< *pos* (length *input*))
           (char= (peek) #\s))
      (parse-L)
      t))

(defun parse (str)
  (setf *input* str)
  (setf *pos* 0)
  (let ((result (parse-I)))
    (if (and result (= *pos* (length *input*)))
        t
        nil)))